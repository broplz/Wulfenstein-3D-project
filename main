/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: broplz <broplz@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2021/03/23 22:30:25 by broplz            #+#    #+#             */
/*   Updated: 2021/04/01 01:01:45 by broplz           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "./include/cub3d.h"

void            my_mlx_pixel_put(t_all *all, int x, int y, int color)
{
	char    *dst;

	dst = all->data.addr + (y * all->data.line_length + x * (all->data.bits_per_pixel / 8));
	*(unsigned int*)dst = color;
}

int             key_hook(int keycode, t_data *vars)
{
	printf("Hello from key_hook!\n");
}

int		key_press(int key, t_all *all)
{
	if(key == 111)
	{
		if(all->map.map[(int)(all->character.posX + all->character.dirX * 0.5)][(int)(all->character.posY)] != '1')
			all->character.posX += all->character.dirX * 0.5;
		if(all->map.map[(int)(all->character.posX)][(int)(all->character.posY + all->character.dirY * 0.5)] != '1')
			all->character.posY += all->character.dirY * 0.5;
		write(1, "test\n", 5);
	}
	//move backwards if no wall behind you
	if(key == 116)
	{
		if(all->map.map[(int)(all->character.posX - all->character.dirX * 0.5)][(int)(all->character.posY)] != '1')
			all->character.posX -= all->character.dirX * 0.5;
		if(all->map.map[(int)(all->character.posX)][(int)(all->character.posY - all->character.dirY * 0.5)] != '1')
			all->character.posY -= all->character.dirY * 0.5;
		write(1, "test2\n", 6);
	}
	draw(all);
	return (0);
	//rotate to the right
}

int		draw(t_all *all)
{
	int x = -1;
	W = 500;
	H = 500;
	while (++x < W)
	{
		all->ray.cameraX = 2 * x / (double)W - 1; //x-coordinate in camera space
		all->ray.rayDirX = all->character.dirX + all->character.planeX*all->ray.cameraX;
		all->ray.rayDirY = all->character.dirY + all->character.planeY*all->ray.cameraX;

		//which box of the map we're in
		all->ray.mapX = (int)all->character.posX;
		all->ray.mapY = (int)all->character.posY;

		//length of ray from one x or y-side to next x or y-side
		all->ray.deltaDistX = fabs(1 / all->ray.rayDirX);
		all->ray.deltaDistY = fabs(1 / all->ray.rayDirY);

		all->ray.hit = 0; //was there a wall hit?
		all->ray.sideDistX = 0;
		if(all->ray.rayDirX < 0)
		{
			all->ray.stepX = -1;
			all->ray.sideDistX = (all->character.posX - all->ray.mapX) * all->ray.deltaDistX;
		}
		else
		{
			all->ray.stepX = 1;
			all->ray.sideDistX = (all->ray.mapX + 1.0 - all->character.posX) * all->ray.deltaDistX;
		}
		if(all->ray.rayDirY < 0)
		{
			all->ray.stepY = -1;
			all->ray.sideDistY = (all->character.posY - all->ray.mapY) * all->ray.deltaDistY;
		}
		else
		{
			all->ray.stepY = 1;
			all->ray.sideDistY = (all->ray.mapY + 1.0 - all->character.posY) * all->ray.deltaDistY;
		}
		while (all->ray.hit == 0)
		{
			//jump to next map square, OR in x-direction, OR in y-direction
			if (all->ray.sideDistX < all->ray.sideDistY)
			{
				all->ray.sideDistX += all->ray.deltaDistX;
				all->ray.mapX += all->ray.stepX;
				all->ray.side = 0;
			}
			else
			{
				all->ray.sideDistY += all->ray.deltaDistY;
				all->ray.mapY += all->ray.stepY;
				all->ray.side = 1;
			}
			//Check if ray has hit a wall
			if (WWORLDMAP[all->ray.mapY][all->ray.mapX] == '1') all->ray.hit = 1;
		}
		//Calculate distance of perpendicular ray (Euclidean distance will give fisheye effect!)
		if (all->ray.side == 0)
		{
			all->ray.perpWallDist = (all->ray.mapX - all->character.posX + (1.0 - all->ray.stepX) / 2) / all->ray.rayDirX;
//			printf("mapX - %d, posX - %f, dirX - %f, perpWallDist - %f\n", all->ray.mapX, all->character.posX, all->ray.rayDirX, all->ray.perpWallDist);
		}
		else
		{
			all->ray.perpWallDist = (all->ray.mapY - all->character.posY + (1.0 - all->ray.stepY) / 2) / all->ray.rayDirY;
//			printf("mapY - %d, posY - %f, dirY - %f, perpWallDist - %f\n", all->ray.mapY, all->character.posY, all->ray.rayDirY, all->ray.perpWallDist);
		}
		//Calculate height of line to draw on screen
		all->ray.lineHeight = (int)(H / all->ray.perpWallDist);

		//calculate lowest and highest pixel to fill in current stripe
		all->ray.drawStart = -all->ray.lineHeight / 2 + H / 2;
		if(all->ray.drawStart < 0) all->ray.drawStart = 0;
		all->ray.drawEnd = all->ray.lineHeight / 2 + H / 2;
		if(all->ray.drawEnd >= H) all->ray.drawEnd = H - 1;

		//texturing calculations
		all->ray.texNum = WWORLDMAP[all->ray.mapY][all->ray.mapX] - 1; //1 subtracted from it so that texture 0 can be used!

		//calculate value of wallX
		all->ray.wallX; //where exactly the wall was hit
		if(all->ray.side == 0) all->ray.wallX = all->character.posY + all->ray.perpWallDist * all->ray.rayDirY;
		else          all->ray.wallX = all->character.posX + all->ray.perpWallDist * all->ray.rayDirX;
		all->ray.wallX -= floor((all->ray.wallX));

		//x coordinate on the texture
		all->ray.texX = (int)(all->ray.wallX * (double)texWidth);
		if(all->ray.side == 0 && all->ray.rayDirX > 0) all->ray.texX = texWidth - all->ray.texX - 1;
		if(all->ray.side == 1 && all->ray.rayDirY < 0) all->ray.texX = texWidth - all->ray.texX - 1;

		// TODO: an integer-only bresenham or DDA like algorithm could make the texture coordinate stepping faster
		// How much to increase the texture coordinate per screen pixel
		all->ray.step = 1.0 * texHeight / all->ray.lineHeight;
		// Starting texture coordinate
		all->ray.texPos = (all->ray.drawStart - H / 2.0 + all->ray.lineHeight / 2.0) * all->ray.step;
//		printf("x - %d\n", x);
//		printf("drawStart - %d\n", all->ray.drawStart);
//		printf("drawEnd - %d\n", all->ray.drawEnd);
		for(int y = all->ray.drawStart; y < all->ray.drawEnd; y++)
		{
			// Cast the texture coordinate to integer, and mask with (texHeight - 1) in case of overflow
			all->ray.texY = (int)all->ray.texPos & (texHeight - 1);
			all->ray.texPos += all->ray.step;
			if(all->ray.side == 1) all->ray.color = 0xff00ff; // (all->ray.color >> 1) & 8355711;
//			printf("x - %d, y - %d\n", x, y);
			my_mlx_pixel_put(all, x, y, 0xff0000); // all->ray.color);
		}
	}
	mlx_put_image_to_window(all->data.mlx, all->data.win, all->data.img, 0, 0);
}

int		main(int argc, char **argv)
{
	t_all	all;
	int		fd;
	int		x;
//	W = 500;
//	H = 500;

	fd = open(argv[1], O_RDONLY);
	ft_main_parser(&all, fd, argc);
	all.data.mlx = mlx_init();
	all.data.win = mlx_new_window(all.data.mlx, 500, 500, "rot");
	all.data.img = mlx_new_image(all.data.mlx, 500, 500);
	all.data.addr = mlx_get_data_addr(all.data.img, &all.data.bits_per_pixel, &all.data.line_length, &all.data.endian);
//	mlx_put_image_to_window(all.data.mlx, all.data.win, all.data.img, 0, 0);

	x = -1;
	all.character.posX = 5.0;
	all.character.posY = 5.0;
	all.character.dirX = -1.0;
	all.character.dirY = 0.0;
	all.character.planeX = 0.0;
	all.character.planeY = 0.66;
	draw(&all);
//	while (++x < W)
//	{
//		all.ray.cameraX = 2 * x / (double)W - 1; //x-coordinate in camera space
//		all.ray.rayDirX = all.character.dirX + all.character.planeX*all.ray.cameraX;
//		all.ray.rayDirY = all.character.dirY + all.character.planeY*all.ray.cameraX;
//
//		//which box of the map we're in
//		all.ray.mapX = (int)all.character.posX;
//		all.ray.mapY = (int)all.character.posY;
//
//		//length of ray from one x or y-side to next x or y-side
//		all.ray.deltaDistX = fabs(1 / all.ray.rayDirX);
//		all.ray.deltaDistY = fabs(1 / all.ray.rayDirY);
//
//		all.ray.hit = 0; //was there a wall hit?
//		all.ray.sideDistX = 0;
//		if(all.ray.rayDirX < 0)
//		{
//			all.ray.stepX = -1;
//			all.ray.sideDistX = (all.character.posX - all.ray.mapX) * all.ray.deltaDistX;
//		}
//		else
//		{
//			all.ray.stepX = 1;
//			all.ray.sideDistX = (all.ray.mapX + 1.0 - all.character.posX) * all.ray.deltaDistX;
//		}
//		if(all.ray.rayDirY < 0)
//		{
//			all.ray.stepY = -1;
//			all.ray.sideDistY = (all.character.posY - all.ray.mapY) * all.ray.deltaDistY;
//		}
//		else
//		{
//			all.ray.stepY = 1;
//			all.ray.sideDistY = (all.ray.mapY + 1.0 - all.character.posY) * all.ray.deltaDistY;
//		}
//		while (all.ray.hit == 0)
//		{
//			//jump to next map square, OR in x-direction, OR in y-direction
//			if (all.ray.sideDistX < all.ray.sideDistY)
//			{
//				all.ray.sideDistX += all.ray.deltaDistX;
//				all.ray.mapX += all.ray.stepX;
//				all.ray.side = 0;
//			}
//			else
//				{
//				all.ray.sideDistY += all.ray.deltaDistY;
//				all.ray.mapY += all.ray.stepY;
//				all.ray.side = 1;
//			}
//			//Check if ray has hit a wall
//			if (WORLDMAP[all.ray.mapY][all.ray.mapX] == '1') all.ray.hit = 1;
//		}
//		//Calculate distance of perpendicular ray (Euclidean distance will give fisheye effect!)
//		if (all.ray.side == 0)
//		{
//			all.ray.perpWallDist = (all.ray.mapX - all.character.posX + (1.0 - all.ray.stepX) / 2) / all.ray.rayDirX;
////			printf("mapX - %d, posX - %f, dirX - %f, perpWallDist - %f\n", all.ray.mapX, all.character.posX, all.ray.rayDirX, all.ray.perpWallDist);
//		}
//		else
//		{
//			all.ray.perpWallDist = (all.ray.mapY - all.character.posY + (1.0 - all.ray.stepY) / 2) / all.ray.rayDirY;
////			printf("mapY - %d, posY - %f, dirY - %f, perpWallDist - %f\n", all.ray.mapY, all.character.posY, all.ray.rayDirY, all.ray.perpWallDist);
//		}
//		//Calculate height of line to draw on screen
//		all.ray.lineHeight = (int)(H / all.ray.perpWallDist);
//
//		//calculate lowest and highest pixel to fill in current stripe
//		all.ray.drawStart = -all.ray.lineHeight / 2 + H / 2;
//		if(all.ray.drawStart < 0) all.ray.drawStart = 0;
//		all.ray.drawEnd = all.ray.lineHeight / 2 + H / 2;
//		if(all.ray.drawEnd >= H) all.ray.drawEnd = H - 1;
//
//		//texturing calculations
//		all.ray.texNum = WORLDMAP[all.ray.mapY][all.ray.mapX] - 1; //1 subtracted from it so that texture 0 can be used!
//
//		//calculate value of wallX
//		all.ray.wallX; //where exactly the wall was hit
//		if(all.ray.side == 0) all.ray.wallX = all.character.posY + all.ray.perpWallDist * all.ray.rayDirY;
//		else          all.ray.wallX = all.character.posX + all.ray.perpWallDist * all.ray.rayDirX;
//		all.ray.wallX -= floor((all.ray.wallX));
//
//		//x coordinate on the texture
//		all.ray.texX = (int)(all.ray.wallX * (double)texWidth);
//		if(all.ray.side == 0 && all.ray.rayDirX > 0) all.ray.texX = texWidth - all.ray.texX - 1;
//		if(all.ray.side == 1 && all.ray.rayDirY < 0) all.ray.texX = texWidth - all.ray.texX - 1;
//
//		// TODO: an integer-only bresenham or DDA like algorithm could make the texture coordinate stepping faster
//		// How much to increase the texture coordinate per screen pixel
//		all.ray.step = 1.0 * texHeight / all.ray.lineHeight;
//		// Starting texture coordinate
//		all.ray.texPos = (all.ray.drawStart - H / 2 + all.ray.lineHeight / 2) * all.ray.step;
////		printf("x - %d\n", x);
////		printf("drawStart - %d\n", all.ray.drawStart);
////		printf("drawEnd - %d\n", all.ray.drawEnd);
//		for(int y = all.ray.drawStart; y < all.ray.drawEnd; y++)
//		{
//			// Cast the texture coordinate to integer, and mask with (texHeight - 1) in case of overflow
//			all.ray.texY = (int)all.ray.texPos & (texHeight - 1);
//			all.ray.texPos += all.ray.step;
//			if(all.ray.side == 1) all.ray.color = 0xff00ff; // (all.ray.color >> 1) & 8355711;
//			printf("x - %d, y - %d\n", x, y);
//			my_mlx_pixel_put(&all, x, y, 0xff0000); // all.ray.color);
//		}
//	}


	//speed modifiers

//	if(keyDown(SDLK_RIGHT))
//	{
//		both camera direction and camera plane must be rotated
//		double oldDirX = dirX;
//		dirX = dirX * cos(-rotSpeed) - dirY * sin(-rotSpeed);
//		dirY = oldDirX * sin(-rotSpeed) + dirY * cos(-rotSpeed);
//		double oldPlaneX = planeX;
//		planeX = planeX * cos(-rotSpeed) - planeY * sin(-rotSpeed);
//		planeY = oldPlaneX * sin(-rotSpeed) + planeY * cos(-rotSpeed);
//	}
	//rotate to the left
//	if(keyDown(SDLK_LEFT))
//	{
//		both camera direction and camera plane must be rotated
//		double oldDirX = dirX;
//		dirX = dirX * cos(rotSpeed) - dirY * sin(rotSpeed);
//		dirY = oldDirX * sin(rotSpeed) + dirY * cos(rotSpeed);
//		double oldPlaneX = planeX;
//		planeX = planeX * cos(rotSpeed) - planeY * sin(rotSpeed);
//		planeY = oldPlaneX * sin(rotSpeed) + planeY * cos(rotSpeed);
//	}
//	if(keyDown(SDLK_ESCAPE))
//	{
//		break;
//	}

//	my_mlx_pixel_put(&img, 0, 0, 0x00FF0000);
	mlx_hook(all.data.win, 2, (1L << 0), &key_press, &all);
	mlx_loop(all.data.mlx);
	return (0);
}